1. 생성 패턴
  - 객체 생성에 관련된 패턴
  - 특정 객체가 추가되거나 변경되어도 구조에 영향을 크게 받지 않도록 함

  - > 1-1. 스트래티지 패턴
    - 행위를 클래스로 캡슐화해 동적으로 행위를 바꿀 수 있게 해주는 패턴
    - 새로운 기능이 기존의 코드에 영향을 미치지 못하게 하므로 OCP를 만족하는 설계

    - 클래스/인터페이스 정의
    ```
    public abstract class Base {
      private String name;
      private Behavior01 behavior01;
      private Behavior02 behavior02;
      
      public do01() { behavior01.do(); }
      public do02() { behavior02.do(); }
      public void setBehavior01(Behavior01) {...}
      public void setBehavior02(Behavior02) {...}
    }
    
    public abstract class Sub01 extends Base {
      public Sub01() { super(); }
    }
    public abstract class Sub02 extends Base {
      public Sub02() { super(); }
    }
    
    public interface Behavior01 {
      public void do();
    }
    public class SubBehavior0101 {
      public void do() { System.out.println("Do behavior0101"); }
    }
    public class SubBehavior0102 {
      public void do() { System.out.println("Do behavior0102"); }
    }
    
    public interface Behavior02 {
      public void do() { System.out.println("Do behavior02"); }
    }
    public class SubBehavior0201 {
      public void do() { System.out.println("Do behavior0201"); }
    }
    public class SubBehavior0202 {
      public void do() { System.out.println("Do behavior0202"); }
    }
    ```
    
    - 사용
    ```
    public static void main(String[] args) {
      Base sub01 = new Sub01();
      Base sub02 = new Sub02();
      
      sub01.setBehavior01(new Behavior0101());
      sub01.setBehavior02(new Behavior0201());
      sub02.setBehavior01(new Behavior0102());
      sub02.setBehavior02(new Behavior0202());
      
      sub01.do01(); // print "Do behavior0101"
      sub01.do02(); // print "Do behavior0201"
      
      sub02.do01(); // print "Do behavior0102"
      sub02.do02(); // print "Do behavior0202"
    }
    ```

2. 구조 패턴
  - 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
  - 서로 다른 인터페이스를 지닌 객체들의 단일 인터페이스를 제공하거나 객체들을 묶어 새로운 기능을 제공하도록 함

3. 행위 패턴
  - 객체나 클래스 간의 책임 분배에 관련된 패턴
  - 한 객체가 수행할 수 없는 작업을 여러 개의 객체로 분배하고 객체 사이의 결합도를 최소화하도록 함
  
  - > 3-1. 커맨드 패턴
    - 실행될 기능을 캡슐화하여 여러 기능을 사용할 수 있는 클래스를 설계하는 패턴
    
    - 클래스/인터페이스 정의
    ```
    public class Base {
      public void commandSub() { System.out.println("Command sub"); }
    }
    
    public class Sub {
      private Base base;
      
      public setBase(Base base) {...}
      public do() { base.commandSub(); }
    }
    ```
    
    - 사용
    ```
    public static void main(String[] args) {
      Base base = new Base();
      Sub sub = new Sub();
      sub.setBase(base);
      
      sub.do(); // print "Command sub"
    }
    ```
